// Generated by CoffeeScript 1.3.3
(function() {
  var EXPORTS_RE, HASH_KEY_RE, HASH_RE, HASH_VALUE_RE, LITERAL_RE, MEMBER_RE, Neat, OBJECT_RE, REQUIRE_RE, SPLIT_MEMBER_RE, STRING_RE, annotate, coffee, compile, exportsToPackage, join, parallel, saveToFile, stripRequires, writeFile;

  Neat = require('../../neat');

  parallel = Neat.require('async').parallel;

  writeFile = require('fs').writeFile;

  coffee = require('coffee-script').compile;

  LITERAL_RE = '[a-zA-Z_$][a-zA-Z0-9_$]*';

  STRING_RE = '["\'][^"\']+["\']';

  HASH_KEY_RE = "(" + LITERAL_RE + "|" + STRING_RE + ")";

  OBJECT_RE = "(\\s*" + HASH_KEY_RE + "(\\s*:\\s*([^,\\n}]+)))+";

  EXPORTS_RE = function() {
    return RegExp("(?:\\s|^)(module\\.exports|exports)(\\s*=\\s*\\n" + OBJECT_RE + "|[=\\[.\\s].+\\n)", "gm");
  };

  SPLIT_MEMBER_RE = function() {
    return /\s*=\s*/g;
  };

  MEMBER_RE = function() {
    return RegExp("\\[\\s*" + STRING_RE + "\\s*\\]|\\." + LITERAL_RE);
  };

  HASH_VALUE_RE = '(\\s*:\\s*([^,}]+))*';

  HASH_RE = function() {
    return RegExp("\\{(" + HASH_KEY_RE + HASH_VALUE_RE + ",*\\s*)+\\}");
  };

  REQUIRE_RE = function() {
    return RegExp("require\\s*(\\(\\s*)*" + STRING_RE, "gm");
  };

  annotate = function(buffer, conf, callback) {
    var content, path;
    for (path in buffer) {
      content = buffer[path];
      buffer[path] = "`// " + path + "`\n\n" + content + "\n";
    }
    return typeof callback === "function" ? callback(buffer, conf) : void 0;
  };

  compile = function(buffer, conf, callback) {
    var content, path;
    for (path in buffer) {
      content = buffer[path];
      path = path.replace('.coffee', '.js');
      buffer[path] = coffee(content, {
        bare: conf.bare
      });
    }
    return typeof callback === "function" ? callback(buffer, conf) : void 0;
  };

  exportsToPackage = function(buffer, conf, callback) {
    var content, header, path, processExports;
    header = function(conf) {
      var p, packages, pkg, _i, _len;
      header = '';
      packages = conf["package"].split('.');
      pkg = "@" + (packages.shift());
      header += "" + pkg + " ||= {}\n";
      for (_i = 0, _len = packages.length; _i < _len; _i++) {
        p = packages[_i];
        pkg += "." + p;
        header += "" + pkg + " ||= {}\n";
      }
      return "" + header + "\n";
    };
    processExports = function(content, conf) {
      var exp, processProperty,
        _this = this;
      processProperty = function(k, v) {
        return "@" + conf["package"] + "." + k + " = " + (v || k);
      };
      exp = [];
      content = content.replace(EXPORTS_RE(), function(m, e, p) {
        var k, member, v, value, values, _i, _j, _len, _len1, _ref, _ref1, _ref2;
        _ref = p.split(SPLIT_MEMBER_RE()), member = _ref[0], value = _ref[1];
        if (MEMBER_RE().test(member)) {
          return "@" + conf["package"] + p;
        } else {
          if (HASH_RE().test(value)) {
            values = value.replace(/\{|\}/g, '').strip().split(',').map(function(s) {
              return s.strip().split(/\s*:\s*/);
            });
            for (_i = 0, _len = values.length; _i < _len; _i++) {
              _ref1 = values[_i], k = _ref1[0], v = _ref1[1];
              exp.push(processProperty(k, v));
            }
          } else if (RegExp("" + OBJECT_RE, "m").test(value)) {
            values = value.split('\n').map(function(s) {
              return s.strip().split(/\s*:\s*/);
            });
            for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
              _ref2 = values[_j], k = _ref2[0], v = _ref2[1];
              exp.push(processProperty(k, v));
            }
          } else {
            value = value.strip();
            exp.push("@" + conf["package"] + "." + value + " = " + value);
          }
          return '';
        }
      });
      return "" + content + "\n" + (exp.join('\n'));
    };
    for (path in buffer) {
      content = buffer[path];
      buffer[path] = "" + (header(conf)) + (processExports(content, conf));
    }
    return typeof callback === "function" ? callback(buffer, conf) : void 0;
  };

  join = function(buffer, conf, callback) {
    var k, newBuffer, newContent, newPath, v;
    newBuffer = {};
    newPath = "" + conf.dir + "/" + conf.name + ".coffee";
    newContent = '';
    for (k in buffer) {
      v = buffer[k];
      newContent += v;
    }
    newBuffer[newPath] = newContent;
    return typeof callback === "function" ? callback(newBuffer, conf) : void 0;
  };

  saveToFile = function(buffer, conf, callback) {
    var gen, k, v;
    gen = function(path, content) {
      return function(callback) {
        return writeFile(path, content, function() {
          return typeof callback === "function" ? callback() : void 0;
        });
      };
    };
    return parallel((function() {
      var _results;
      _results = [];
      for (k in buffer) {
        v = buffer[k];
        _results.push(gen(k, v));
      }
      return _results;
    })(), function() {
      return typeof callback === "function" ? callback(buffer, conf) : void 0;
    });
  };

  stripRequires = function(buffer, conf, callback) {
    var content, path;
    for (path in buffer) {
      content = buffer[path];
      buffer[path] = content.split('\n').reject(function(s) {
        return REQUIRE_RE().test(s);
      }).join('\n');
    }
    return typeof callback === "function" ? callback(buffer, conf) : void 0;
  };

  module.exports = {
    annotate: annotate,
    compile: compile,
    exportsToPackage: exportsToPackage,
    join: join,
    saveToFile: saveToFile,
    stripRequires: stripRequires
  };

}).call(this);
