// Generated by CoffeeScript 1.3.3
(function() {
  var EXPORTS_RE, HASH_KEY_RE, HASH_RE, HASH_VALUE_RE, LITERAL_RE, MEMBER_RE, NAME_RE, Neat, OBJECT_RE, PACKAGE_RE, Packager, REQUIRE_RE, SPLIT_MEMBER_RE, STRING_RE, compile, ensure, readFiles, writeFile, _ref;

  Neat = require('../../neat');

  writeFile = require('fs').writeFile;

  _ref = Neat.require('utils/files'), readFiles = _ref.readFiles, ensure = _ref.ensure;

  compile = require('coffee-script').compile;

  LITERAL_RE = '[a-zA-Z_$][a-zA-Z0-9_$]*';

  STRING_RE = '["\'][^"\']+["\']';

  HASH_KEY_RE = "(" + LITERAL_RE + "|" + STRING_RE + ")";

  OBJECT_RE = "(\\s*" + HASH_KEY_RE + "(\\s*:\\s*([^,\\n}]+)))+";

  PACKAGE_RE = function() {
    return RegExp("^(" + LITERAL_RE + ")(\\." + LITERAL_RE + ")*$");
  };

  NAME_RE = function() {
    return /^[a-zA-Z_$][a-zA-Z0-9_$-]*$/;
  };

  EXPORTS_RE = function() {
    return RegExp("(?:\\s|^)(module\\.exports|exports)(\\s*=\\s*\\n" + OBJECT_RE + "|[=\\[.\\s].+\\n)", "gm");
  };

  SPLIT_MEMBER_RE = function() {
    return /\s*=\s*/g;
  };

  MEMBER_RE = function() {
    return RegExp("\\[\\s*" + STRING_RE + "\\s*\\]|\\." + LITERAL_RE);
  };

  HASH_VALUE_RE = '(\\s*:\\s*([^,}]+))*';

  HASH_RE = function() {
    return RegExp("\\{(" + HASH_KEY_RE + HASH_VALUE_RE + ",*\\s*)+\\}");
  };

  REQUIRE_RE = function() {
    return RegExp("(^|([^=]+=\\s*)*)require\\s*" + STRING_RE + "\\s*", "gm");
  };

  Packager = (function() {

    Packager.asCommand = function(conf) {
      return function(callback) {
        return new Packager(conf).process(callback);
      };
    };

    function Packager(conf) {
      var malformedConf, preventMissingConf, validate,
        _this = this;
      this.conf = conf;
      validate = function(key, re, expect) {
        if (!re.test(_this.conf[key])) {
          throw new Error("Malformed string for " + key + ", expect " + expect);
        }
      };
      malformedConf = function(key, type) {
        return new Error("Malformed configuration for " + key + ", expect " + type);
      };
      preventMissingConf = function(key) {
        if (_this.conf[key] == null) {
          throw new Error("Missing configuration " + key);
        }
      };
      preventMissingConf('name');
      preventMissingConf('includes');
      if (!Array.isArray(this.conf['includes'])) {
        malformedConf('includes', 'Array');
      }
      validate('name', NAME_RE(), 'a file name such foo_bar of foo-bar');
      validate('package', PACKAGE_RE(), 'a path such com.exemple.foo');
    }

    Packager.prototype.process = function(callback) {
      var files, tmp,
        _this = this;
      tmp = Neat.config.tasks["package"].tmp;
      files = this.conf.includes.map(function(p) {
        return "" + Neat.root + "/" + p + ".coffee";
      });
      return readFiles(files, function(err, res) {
        var content, k, v;
        content = _this.header();
        for (k in res) {
          v = res[k];
          content += _this.processFile(k, v);
        }
        content = _this.processExports(content);
        _this.result = content;
        _this.js = compile(content, {
          bare: _this.conf.bare
        });
        return writeFile("" + tmp + "/" + _this.conf.name + ".coffee", content, function(err) {
          return writeFile("" + tmp + "/" + _this.conf.name + ".js", _this.js, function(err) {
            return typeof callback === "function" ? callback() : void 0;
          });
        });
      });
    };

    Packager.prototype.processFile = function(k, v) {
      v = this.stripRequires(v);
      return "`// " + k + "`\n\n" + v + "\n";
    };

    Packager.prototype.processExports = function(content) {
      var exp,
        _this = this;
      exp = [];
      content = content.replace(EXPORTS_RE(), function(m, e, p) {
        var k, member, v, value, values, _i, _j, _len, _len1, _ref1, _ref2, _ref3;
        _ref1 = p.split(SPLIT_MEMBER_RE()), member = _ref1[0], value = _ref1[1];
        if (MEMBER_RE().test(member)) {
          return "@" + _this.conf["package"] + p;
        } else {
          if (HASH_RE().test(value)) {
            values = value.replace(/\{|\}/g, '').strip().split(',').map(function(s) {
              return s.strip().split(/\s*:\s*/);
            });
            for (_i = 0, _len = values.length; _i < _len; _i++) {
              _ref2 = values[_i], k = _ref2[0], v = _ref2[1];
              exp.push(_this.processProperty(k, v));
            }
          } else if (RegExp("" + OBJECT_RE, "m").test(value)) {
            values = value.split('\n').map(function(s) {
              return s.strip().split(/\s*:\s*/);
            });
            for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
              _ref3 = values[_j], k = _ref3[0], v = _ref3[1];
              exp.push(_this.processProperty(k, v));
            }
          } else {
            value = value.strip();
            exp.push("@" + _this.conf["package"] + "." + value + " = " + value);
          }
          return '';
        }
      });
      return "" + content + "\n" + (exp.join('\n'));
    };

    Packager.prototype.processProperty = function(k, v) {
      if (v == null) {
        v = k;
      }
      return "@" + this.conf["package"] + "." + k + " = " + v;
    };

    Packager.prototype.stripRequires = function(content) {
      return content.split('\n').reject(function(s) {
        return s.indexOf('require') !== -1;
      }).join('\n');
    };

    Packager.prototype.header = function() {
      var header, p, packages, pkg, _i, _len;
      header = '';
      packages = this.conf["package"].split('.');
      pkg = "@" + (packages.shift());
      header += "" + pkg + " ||= {}\n";
      for (_i = 0, _len = packages.length; _i < _len; _i++) {
        p = packages[_i];
        pkg += "." + p;
        header += "" + pkg + " ||= {}\n";
      }
      return "" + header + "\n";
    };

    return Packager;

  })();

  module.exports = Packager;

}).call(this);
