// Generated by CoffeeScript 1.3.3
(function() {
  var Neat, aliases, describe, error, generate, help, helpCmd, missing, puts, render, resolve, run, usages, utils, warn, _ref, _ref1,
    __slice = [].slice;

  resolve = require('path').resolve;

  helpCmd = require('./help.cmd').help;

  Neat = require('../neat').Neat;

  utils = resolve(Neat.neatRoot, "lib/utils");

  _ref = require(resolve(utils, "logs")), puts = _ref.puts, error = _ref.error, warn = _ref.warn, missing = _ref.missing;

  _ref1 = require(resolve(utils, "commands")), run = _ref1.run, aliases = _ref1.aliases, usages = _ref1.usages, describe = _ref1.describe, help = _ref1.help;

  render = require(resolve(utils, "templates")).renderSync;

  generate = function(pr, commands) {
    var f, generators, helpFunc, listContext;
    if (pr == null) {
      return puts(error("No program provided to generate"));
    }
    generators = require(resolve(Neat.neatRoot, "lib/generators"));
    listContext = {
      list: generators,
      title: "Generators:"
    };
    helpFunc = function(target) {
      return function(generator) {
        var context, gen, helptpl;
        helptpl = resolve(__dirname, "help");
        if ((generator != null) && typeof generator === 'string') {
          gen = generators[generator];
          if (gen != null) {
            if ((gen.help != null) && typeof gen.help === 'function') {
              return gen.help.apply(null, arguments);
            } else {
              return puts(render(helptpl, gen));
            }
          } else {
            return puts(missing("Generator " + generator));
          }
        } else {
          context = {};
          context.merge(target);
          context.help = render(resolve(__dirname, "help/_list"), listContext);
          return puts(render(helptpl, context));
        }
      };
    };
    aliases('g', 'generate', usages('neat generate [generator]', describe('Runs the specified [generator].', f = function() {
      var args, callback, command, gen, generator, _i;
      generator = arguments[0], args = 4 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 2) : (_i = 1, []), command = arguments[_i++], callback = arguments[_i++];
      if (typeof generator === "object") {
        return f.help.apply(null, arguments) && (typeof callback === "function" ? callback() : void 0);
      }
      if (args.length === 0) {
        if (typeof command !== "object") {
          args.push(command);
        }
      } else if (typeof callback !== "function") {
        args.push(command) && (command = callback);
      }
      if (!(generator in generators)) {
        return puts(missing("Generator " + generator));
        if (typeof callback === "function") {
          callback();
        }
      }
      gen = generators[generator];
      if (typeof gen !== "function") {
        return puts(error("Generators must be a function, was " + (typeof gen)));
        if (typeof callback === "function") {
          callback();
        }
      }
      return gen.apply(null, [generator].concat(args).concat(callback));
    })));
    return help(helpFunc(f), f);
  };

  module.exports = {
    generate: generate
  };

}).call(this);
